/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SearchInCanvasPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// node_modules/monkey-around/dist/index.mjs
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const inherited = obj[method], hadOwn = obj.hasOwnProperty(method), original = hadOwn ? inherited : function() {
    return Object.getPrototypeOf(obj)[method].apply(this, arguments);
  };
  let current = createWrapper(original);
  if (inherited)
    Object.setPrototypeOf(current, inherited);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, inherited || Function);
  }
}

// src/searchInit.ts
var import_obsidian2 = require("obsidian");

// src/searchPanel.ts
var import_obsidian = require("obsidian");

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var min = Math.min;
var max = Math.max;
var round = Math.round;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle(element);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x = rect.left + scroll.scrollLeft - offsets.x;
  const y = rect.top + scroll.scrollTop - offsets.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
var offset2 = offset;
var flip2 = flip;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// src/searchPanel.ts
var remote = import_obsidian.Platform.isDesktop ? require("electron").remote : null;
var SearchPanel = class extends import_obsidian.Component {
  constructor(canvas, targetEl) {
    super();
    this.floatingElement = null;
    this.inputContainerEl = null;
    this.countEl = null;
    this.infoEl = null;
    this.searchBar = null;
    this.currentIndex = 0;
    this.highlightedNodes = /* @__PURE__ */ new Map();
    this.selectedNode = null;
    this.prevBtn = null;
    this.nextBtn = null;
    this.configBtn = null;
    this.searchEdge = true;
    this.searchGroup = true;
    this.isSelfCalled = false;
    this.debounceSearch = (0, import_obsidian.debounce)(this.onSearch, 300);
    this.canvas = canvas;
    this.targetEl = targetEl;
  }
  onload() {
    var _a;
    super.onload();
    this.floatingElement = createEl("div", {
      cls: "canvas-search-panel"
    });
    this.floatingElement.hide();
    const searchBarContainer = this.floatingElement.createEl("div", {
      cls: "canvas-search-bar-container"
    });
    const matchCountEl = this.floatingElement.createEl("div", {
      cls: "canvas-search-match-count"
    });
    this.inputContainerEl = searchBarContainer.createEl("div", {
      cls: ["canvas-search-input-container", "is-empty"]
    });
    this.searchBar = new import_obsidian.SearchComponent(this.inputContainerEl);
    this.searchBar.onChange((value) => {
      var _a2, _b, _c;
      if (value === "") {
        this.highlightedNodes.forEach((node) => {
          var _a3;
          (_a3 = node == null ? void 0 : node.nodeEl) == null ? void 0 : _a3.toggleClass("canvas-search-highlight", false);
          if (this.searchEdge) {
            node.deselect();
            node.blur();
          }
        });
        (_a2 = this.inputContainerEl) == null ? void 0 : _a2.toggleClass("is-empty", true);
        this.highlightedNodes.clear();
        (_b = this.countEl) == null ? void 0 : _b.hide();
        this.canvas.wrapperEl.toggleClass("is-searching", false);
      }
      (_c = this.inputContainerEl) == null ? void 0 : _c.toggleClass("is-empty", value === "");
      this.debounceSearch();
    });
    this.searchBar.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const action = e.ctrlKey ? "edit" : e.shiftKey ? "previous" : "next";
        if (action === "edit" && this.selectedNode) {
          this[action]();
          return;
        }
        if (this.highlightedNodes.size > 1) {
          this[action]();
          return;
        }
        this.onSearch();
        if (this.highlightedNodes.size === 1) {
          const node = this.highlightedNodes.values().next().value;
          this.selectAndZoom(node);
        }
      }
      if (e.key === "Escape") {
        e.preventDefault();
        e.stopPropagation();
        this.hide();
      }
    });
    const buttonGroup = searchBarContainer.createEl("div", {
      cls: "canvas-search-button-group"
    });
    this.prevBtn = new import_obsidian.ButtonComponent(buttonGroup.createEl("div", {
      cls: ["canvas-search-prev-btn-container", "canvas-search-control-item"]
    })).setIcon("chevron-left").onClick(() => {
      this.previous();
    });
    this.nextBtn = new import_obsidian.ButtonComponent(buttonGroup.createEl("div", {
      cls: ["canvas-search-next-btn-container", "canvas-search-control-item"]
    })).setIcon("chevron-right").onClick(() => {
      this.next();
    });
    this.infoEl = this.floatingElement.createEl("div", {
      cls: "canvas-search-info-panel"
    });
    [{
      desc: "Start searching",
      hotkeys: ["Enter", "Shift+Enter"]
    }, {
      desc: "Select next match",
      hotkeys: [(import_obsidian.Platform.isMacOS ? "Command" : "Ctrl") + "+G", "F3"]
    }, {
      desc: "Select previous match",
      hotkeys: [(import_obsidian.Platform.isMacOS ? "Command" : "Ctrl") + "+Shift+G", "Shift+F3"]
    }, {
      desc: "Edit selected node",
      hotkeys: [(import_obsidian.Platform.isMacOS ? "Command" : "Ctrl") + "+Enter"]
    }, {
      desc: "Close search",
      hotkeys: ["Esc"]
    }].forEach(({ desc, hotkeys }) => this.createInstruction(desc, hotkeys));
    this.infoEl.hide();
    this.countEl = matchCountEl.createEl("span", {
      cls: "canvas-search-count"
    });
    (_a = this.countEl) == null ? void 0 : _a.hide();
    matchCountEl.createEl("span", {
      cls: "spacer"
    });
    matchCountEl.createEl("span", {
      cls: "canvas-search-info"
    }, (el) => {
      this.configBtn = new import_obsidian.ButtonComponent(el.createEl("div", {
        cls: ["canvas-search-config-btn-container", "canvas-search-control-item"]
      })).setIcon("settings-2").onClick((evt) => {
        const menu = new import_obsidian.Menu();
        menu.addItem((item) => {
          item.setTitle("Group").setChecked(this.searchGroup).onClick(() => {
            this.searchGroup = !this.searchGroup;
            this.onSearch();
          });
        });
        menu.addItem((item) => {
          item.setTitle("Edge").setChecked(this.searchEdge).onClick(() => {
            this.searchEdge = !this.searchEdge;
            this.onSearch();
          });
        });
        menu.showAtMouseEvent(evt);
      });
      new import_obsidian.ExtraButtonComponent(el).setIcon("help-circle").onClick(() => {
        if (!this.infoEl)
          return;
        this.infoEl.isShown() ? this.infoEl.hide() : this.infoEl.show();
      });
    });
    this.canvas.wrapperEl.appendChild(this.floatingElement);
  }
  onunload() {
    super.onunload();
    if (this.floatingElement) {
      this.floatingElement.detach();
    }
  }
  createInstruction(desc, hotkeys) {
    var _a;
    (_a = this.infoEl) == null ? void 0 : _a.createDiv({
      cls: "canvas-instruction"
    }, (n) => {
      n.createDiv({
        cls: "canvas-instruction-label",
        text: desc
      });
      n.createDiv({
        cls: "canvas-instruction-desc"
      }, (e) => {
        for (let n2 = 0, i = hotkeys; n2 < i.length; n2++) {
          let r = i[n2];
          e.createSpan({
            cls: "setting-hotkey",
            text: r
          });
        }
      });
    });
  }
  show() {
    if (this.floatingElement) {
      this.floatingElement.show();
      this.floatingElement.toggleClass("is-shown", true);
      computePosition2(this.targetEl, this.floatingElement, {
        placement: "left-start",
        middleware: [offset2(6), flip2()]
      }).then(({ x, y }) => {
        if (!this.floatingElement)
          return;
        Object.assign(this.floatingElement.style, {
          left: `${x}px`,
          top: `${y}px`
        });
      });
      this.focus();
      const captureEvent = (e) => {
        if (this.isSelfCalled) {
          this.isSelfCalled = false;
          return;
        }
        if (e.target.closest(".menu") || e.target.closest(".canvas-search-panel") || e.target.closest(".canvas-control-item"))
          return;
        this.hide();
        activeDocument.body.removeEventListener("click", captureEvent, { capture: true });
      };
      activeDocument.body.addEventListener("click", captureEvent, { capture: true });
    }
  }
  updatePosition() {
    if (this.floatingElement && this.floatingElement.isShown()) {
      computePosition2(this.targetEl, this.floatingElement, {
        placement: "left-start",
        middleware: [offset2(6), flip2()]
      }).then(({ x, y }) => {
        if (!this.floatingElement)
          return;
        Object.assign(this.floatingElement.style, {
          left: `${x}px`,
          top: `${y}px`
        });
      });
    }
  }
  hide() {
    var _a;
    if (this.floatingElement) {
      (_a = this.searchBar) == null ? void 0 : _a.clearButtonEl.click();
      this.floatingElement.hide();
      this.floatingElement.toggleClass("is-shown", false);
      this.highlightedNodes.forEach((node) => {
        var _a2;
        (_a2 = node == null ? void 0 : node.nodeEl) == null ? void 0 : _a2.toggleClass("canvas-search-highlight", false);
        if (this.searchEdge) {
          node.deselect();
          node.blur();
        }
      });
      this.highlightedNodes.clear();
      this.selectedNode = null;
      this.infoEl && this.infoEl.hide();
      this.canvas.wrapperEl.toggleClass("is-searching", false);
      this.canvas.wrapperEl.focus();
    }
  }
  next() {
    if (this.highlightedNodes.size === 0)
      this.onSearch();
    if (this.highlightedNodes.size === 0)
      return;
    const nodes = Array.from(this.highlightedNodes.values());
    if (nodes.length === 1) {
      this.selectAndZoom(nodes[0]);
      return;
    }
    this.currentIndex = (this.currentIndex + 1) % nodes.length;
    this.selectedNode = nodes[this.currentIndex];
    this.selectAndZoom(nodes[this.currentIndex]);
  }
  previous() {
    if (this.highlightedNodes.size === 0)
      this.onSearch();
    if (this.highlightedNodes.size === 0)
      return;
    const nodes = Array.from(this.highlightedNodes.values());
    if (nodes.length === 1) {
      this.selectAndZoom(nodes[0]);
      return;
    }
    this.currentIndex = (this.currentIndex - 1 + nodes.length) % nodes.length;
    this.selectedNode = nodes[this.currentIndex];
    this.selectAndZoom(nodes[this.currentIndex]);
  }
  selectAndZoom(node) {
    if (this.searchEdge && node.lineGroupEl) {
      this.canvas.selectOnly(node);
      this.canvas.zoomToSelection();
      return;
    }
    this.canvas.selectOnly(node);
    this.canvas.zoomToSelection();
  }
  focus() {
    var _a;
    if (this.searchBar) {
      (_a = this.searchBar) == null ? void 0 : _a.inputEl.focus();
    }
  }
  edit() {
    if (this.selectedNode) {
      const isEdge = this.searchEdge && !!this.selectedNode.lineGroupEl;
      !isEdge ? this.selectedNode.startEditing() : (() => {
        var _a, _b;
        (_a = this.selectedNode.labelElement) == null ? void 0 : _a.focus();
        this.isSelfCalled = true;
        (_b = this.selectedNode.labelElement) == null ? void 0 : _b.wrapperEl.click();
      })();
    }
  }
  isShown() {
    var _a, _b;
    return (_b = (_a = this.floatingElement) == null ? void 0 : _a.isShown()) != null ? _b : false;
  }
  fuzzySearchItemsOptimized(query, items) {
    const preparedSearch = (0, import_obsidian.prepareFuzzySearch)(query);
    return items.map((item) => {
      const result = preparedSearch(item.value);
      if (result) {
        return {
          item,
          match: result,
          score: result.score
        };
      }
      return null;
    }).sort((a, b) => ((b == null ? void 0 : b.score) || 0) - ((a == null ? void 0 : a.score) || 0)).filter(Boolean).filter((a) => {
      return (a == null ? void 0 : a.score) > -5;
    });
  }
  async onSearch() {
    var _a, _b, _c;
    this.currentIndex = 0;
    const value = (_a = this.searchBar) == null ? void 0 : _a.inputEl.value;
    if (!value)
      return;
    this.canvas.wrapperEl.toggleClass("is-searching", true);
    const searchableNodes = [];
    for (const node of this.canvas.nodes.values()) {
      const nodeProperties = ["text", "filePath", "url", this.searchGroup ? "label" : ""];
      for (const prop of nodeProperties) {
        if (!prop)
          continue;
        if (node[prop]) {
          let searchValue = node[prop];
          if (prop === "url" && node.frameEl && import_obsidian.Platform.isDesktop) {
            const frameEl = node.frameEl;
            if (!this.canvas.wrapperEl.contains(frameEl))
              continue;
            const webContents = remote.webContents.fromId(frameEl.getWebContentsId());
            try {
              const bodyText = await webContents.executeJavaScript(`document.body.innerText;`, true);
              const title = webContents.getTitle();
              searchValue += ` - ${title} - ${bodyText}`;
            } catch (error) {
              console.error("Error fetching web contents: ", error);
            }
          }
          if (node.file && node.child && node.child.data && node.file.extension === "md") {
            searchValue = node.file.basename + "\n" + node.child.data;
          } else if (node.file && node.file.extension === "md") {
            const fileContent = await this.canvas.app.vault.cachedRead(node.file);
            searchValue = node.file.basename + "\n" + fileContent;
          }
          searchableNodes.push({ node, value: searchValue });
          break;
        }
      }
    }
    if (this.searchEdge) {
      for (const node of this.canvas.edges.values()) {
        const label = node.label;
        if (label) {
          searchableNodes.push({ node, value: label });
        }
      }
    }
    const searchResults = this.fuzzySearchItemsOptimized(value, searchableNodes);
    const nodeMap = /* @__PURE__ */ new Map();
    this.highlightedNodes.forEach((node) => {
      var _a2;
      (_a2 = node == null ? void 0 : node.nodeEl) == null ? void 0 : _a2.toggleClass("canvas-search-highlight", false);
      if (node.lineGroupEl) {
        node.deselect();
        node.blur();
      }
    });
    searchResults.forEach(({ item }) => {
      const { node } = item;
      if (node.nodeEl) {
        node.nodeEl.toggleClass("canvas-search-highlight", true);
        nodeMap.set(node.id, node);
      } else if (this.searchEdge && node.lineGroupEl) {
        node.select();
        nodeMap.set(node.id, node);
      }
    });
    this.highlightedNodes = nodeMap;
    if (this.countEl) {
      (_b = this.countEl) == null ? void 0 : _b.setText(`${searchResults.length} matches`);
      (_c = this.countEl) == null ? void 0 : _c.show();
      (0, import_obsidian.setTooltip)(this.countEl, "Press Enter to select the next match");
    }
  }
};

// src/searchInit.ts
var updateView = (plugin, view) => {
  if (view.patched)
    return;
  patchKeys(plugin, view.scope);
  initScope(plugin, view);
  const button = createSearchButton(view.canvas, plugin);
  plugin.searchButton.push(button);
  view.patched = true;
};
var initScope = (plugin, view) => {
  var _a, _b, _c, _d, _e;
  (_a = view.scope) == null ? void 0 : _a.register(["Mod"], "f", () => {
    var _a2, _b2;
    if (!((_a2 = view.canvas) == null ? void 0 : _a2.searchPanel)) {
      if (!view.canvas.searchButton) {
        const button = createSearchButton(view.canvas, plugin);
        plugin.searchButton.push(button);
      }
      view.canvas.searchPanel = createSearchPanel(view.canvas, view.canvas.searchButton);
      view.canvas.searchPanel.load();
      plugin.searchPanel.push(view.canvas.searchPanel);
    }
    view.canvas.searchPanel.isShown() ? (_b2 = view.canvas.searchPanel) == null ? void 0 : _b2.focus() : view.canvas.searchPanel.show();
  });
  (_b = view.scope) == null ? void 0 : _b.register(["Mod"], "g", () => {
    if (view.canvas.searchPanel && view.canvas.searchPanel.isShown()) {
      view.canvas.searchPanel.next();
    }
  });
  (_c = view.scope) == null ? void 0 : _c.register(["Mod", "Shift"], "g", () => {
    if (view.canvas.searchPanel && view.canvas.searchPanel.isShown()) {
      view.canvas.searchPanel.previous();
    }
  });
  (_d = view.scope) == null ? void 0 : _d.register([], "F3", () => {
    if (view.canvas.searchPanel && view.canvas.searchPanel.isShown()) {
      view.canvas.searchPanel.next();
    }
  });
  (_e = view.scope) == null ? void 0 : _e.register(["Shift"], "F3", () => {
    if (view.canvas.searchPanel && view.canvas.searchPanel.isShown()) {
      view.canvas.searchPanel.previous();
    }
  });
};
var patchKeys = (plugin, scope) => {
  scope.keys.forEach((key) => {
    const oldFunc = key.func;
    key.func = (e) => {
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement)
        return;
      oldFunc(e);
    };
    key.func._original = oldFunc;
  });
  const uninstaller = () => {
    scope.keys.forEach((key) => {
      key.func = key.func._original || key.func;
    });
  };
  plugin.register(uninstaller);
};
var createSearchPanel = (canvas, targetEl) => {
  return new SearchPanel(canvas, targetEl);
};
var createSearchButton = (canvas, plugin) => {
  if (canvas.searchButton)
    return canvas.searchButton;
  const groupEl = createEl("div", {
    cls: "canvas-control-group"
  });
  const searchButton = groupEl.createEl("div", {
    cls: "canvas-control-item"
  });
  (0, import_obsidian2.setIcon)(searchButton, "search");
  (0, import_obsidian2.setTooltip)(searchButton, "Search", {
    placement: "left"
  });
  searchButton.addEventListener("click", () => {
    if (!canvas.searchPanel) {
      canvas.searchPanel = createSearchPanel(canvas, searchButton);
      canvas.searchPanel.load();
      plugin.searchPanel.push(canvas.searchPanel);
    }
    canvas.searchPanel.isShown() ? canvas.searchPanel.hide() : canvas.searchPanel.show();
  });
  canvas.canvasControlsEl.prepend(groupEl);
  canvas.searchButton = searchButton;
  canvas.searchButtonGroup = groupEl;
  return searchButton;
};

// src/main.ts
var SearchInCanvasPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.searchPanel = [];
    this.searchButton = [];
    this.patchAlready = false;
  }
  async onload() {
    this.patchCanvas();
    this.app.workspace.onLayoutReady(() => {
      const leaves = this.app.workspace.getLeavesOfType("canvas");
      leaves.forEach((leaf) => {
        updateView(this, leaf.view);
      });
    });
  }
  onunload() {
    this.searchPanel.forEach((panel) => panel.unload());
    this.searchButton.forEach((button) => {
      if (button.parentElement)
        button.parentElement.detach();
    });
    const leaves = this.app.workspace.getLeavesOfType("canvas");
    leaves.forEach((leaf) => {
      if (leaf.view.patched) {
        leaf.view.canvas.searchPanel = null;
        leaf.view.canvas.searchButton = null;
        leaf.view.patched = false;
      }
    });
  }
  patchCanvas() {
    const init = (plugin) => {
      var _a;
      if (plugin.patchAlready)
        return true;
      const view = (_a = plugin.app.workspace.getLeavesOfType("canvas")[0]) == null ? void 0 : _a.view;
      if (!view)
        return false;
      const canvas = view.canvas;
      if (!canvas)
        return false;
      const uninstaller = around(view.constructor.prototype, {
        onload: (next) => {
          return function() {
            next.apply(this);
            updateView(plugin, this);
          };
        },
        onResize: (next) => {
          return function(...args) {
            var _a2, _b, _c, _d, _e;
            next.apply(this, args);
            ((_a2 = this.canvas) == null ? void 0 : _a2.searchPanel) && ((_c = (_b = this.canvas) == null ? void 0 : _b.searchPanel) == null ? void 0 : _c.isShown()) && ((_e = (_d = this.canvas) == null ? void 0 : _d.searchPanel) == null ? void 0 : _e.updatePosition());
          };
        },
        onunload: (next) => {
          return function() {
            var _a2, _b, _c;
            next.apply(this);
            if ((_a2 = this.canvas) == null ? void 0 : _a2.searchPanel) {
              this.canvas.searchPanel.unload();
              (_b = this.canvas.searchButton) == null ? void 0 : _b.detach();
              (_c = this.canvas.searchButtonGroup) == null ? void 0 : _c.detach();
              this.canvas.searchPanel = null;
              this.canvas.searchButton = null;
              this.patched = false;
            }
          };
        }
      });
      this.register(uninstaller);
      this.patchAlready = true;
    };
    this.app.workspace.onLayoutReady(() => {
      if (!init(this)) {
        const evt = this.app.workspace.on("layout-change", () => {
          init(this) && this.app.workspace.offref(evt);
        });
        this.registerEvent(evt);
      }
    });
    const initPatch = (plugin) => {
      const leafUninstaller = around(import_obsidian3.WorkspaceLeaf.prototype, {
        openFile: (next) => {
          return async function(viewState, eState) {
            const result = await next.apply(this, [viewState, eState]);
            if (plugin.patchAlready) {
              leafUninstaller();
              return;
            }
            if (this.view instanceof import_obsidian3.View && this.view.canvas && !this.view.canvas.searchPanel) {
              init(plugin);
              updateView(plugin, this.view);
              leafUninstaller();
            }
            return result;
          };
        }
      });
      this.register(leafUninstaller);
    };
    initPatch(this);
  }
};

/* nosourcemap */