/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CanvasLinksPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var VIEW_TYPE = "canvas-links";
var CanvasLinksPlugin = class extends import_obsidian.Plugin {
  async onload() {
    var _a;
    this.registerView(VIEW_TYPE, (leaf) => new CanvasLinksView(leaf));
    const leafs = this.app.workspace.getLeavesOfType(VIEW_TYPE);
    if (isEmpty(leafs)) {
      (_a = this.app.workspace.getRightLeaf(false)) == null ? void 0 : _a.setViewState({
        type: VIEW_TYPE,
        active: true
      });
    } else {
      this.app.workspace.revealLeaf(leafs[0]);
    }
  }
};
var CanvasLinksView = class extends import_obsidian.ItemView {
  constructor(leaf) {
    super(leaf);
    this.selectedNodeId = null;
    this.canvasNode = /* @__PURE__ */ new Map();
  }
  getViewType() {
    return VIEW_TYPE;
  }
  getDisplayText() {
    return "Canvas Links";
  }
  async onOpen() {
    this.icon = "align-center-horizontal";
    this.containerEl.empty();
    const element = this.renderPane();
    const view = this.app.workspace.getLeaf().view;
    if (view.file != null) {
      this.render(element, view);
    }
    this.registerEvent(this.app.vault.on("modify", (file) => {
      var _a;
      if ("canvas" != file.extension) {
        return;
      }
      const view2 = this.app.workspace.getLeaf().view;
      const filePath = file.path;
      const previousNodeIds = (_a = this.canvasNode.get(filePath)) != null ? _a : [];
      const canvas = view2.canvas;
      let currentNodeIds = [];
      for (const [key, value] of canvas.nodes) {
        if (value.file != null) {
          currentNodeIds.push(key);
        }
      }
      if (currentNodeIds.length != previousNodeIds.length) {
        this.canvasNode.set(filePath, currentNodeIds);
        this.render(element, view2);
      }
    }));
    this.registerEvent(this.app.workspace.on("active-leaf-change", (leaf) => {
      const afterChangeView = leaf.view;
      if (afterChangeView.file == null) {
        if ("empty" === afterChangeView.getViewType()) {
          element.empty();
        }
      } else {
        if ("canvas" === afterChangeView.getViewType() && this.selectedNodeId != null) {
          const canvas = afterChangeView.canvas;
          for (const [key, value] of canvas.nodes) {
            if (key === this.selectedNodeId) {
              focus(canvas, value);
              this.selectedNodeId = null;
              break;
            }
          }
        }
        this.render(element, afterChangeView);
      }
    }));
  }
  renderPane() {
    return this.containerEl.createDiv({
      cls: "outgoing-link-pane node-insert-event",
      attr: { "style": "position: relative;" }
    });
  }
  render(body, view) {
    body.empty();
    if ("canvas" === view.getViewType()) {
      this.renderFiles(body, view.file, view.canvas.nodes);
      this.renderCanvases(body, view.file);
    } else {
      this.renderCanvases(body, view.file);
    }
  }
  renderFiles(body, currentFile, nodes) {
    const header = body.createDiv({
      cls: "tree-item-self is-clickable",
      attr: {
        "aria-label": "Click to collapse",
        "aria-label-position": "right"
      }
    });
    header.createSpan({ cls: "tree-item-icon collapse-icon" });
    header.createDiv({
      cls: "tree-item-inner",
      text: "FILE CONTAIN"
    });
    const files = this.getFiles(currentFile, nodes);
    header.createDiv({ cls: "tree-item-flair-outer" }, (el) => {
      el.createSpan({
        cls: "tree-item-flair",
        text: files.length.toString()
      });
    });
    if (isEmpty(files)) {
      return;
    }
    const content = body.createDiv({ cls: "search-result-container" });
    content.createDiv({
      attr: {
        "style": "width: 1px; height: 0.1px; margin-bottom: 0px;"
      }
    });
    for (const file of files) {
      content.createDiv({
        cls: "tree-item-self is-clickable outgoing-link-item",
        attr: { "draggable": true }
      }, (el) => {
        el.createSpan({ cls: "tree-item-icon" }, (el2) => {
          if ("md" === file.extension) {
            (0, import_obsidian.setIcon)(el2, "file-text");
          } else {
            (0, import_obsidian.setIcon)(el2, "file-image");
          }
        });
        el.createDiv({
          cls: "tree-item-inner",
          text: file.name.substring(0, file.name.lastIndexOf("."))
          // don't show path, like link view
        });
      }).addEventListener("click", () => {
        this.app.workspace.openLinkText("", file.path);
      });
      ;
    }
  }
  async renderCanvases(body, currentFile) {
    const header = body.createDiv({
      cls: "tree-item-self is-clickable",
      attr: {
        "aria-label": "Click to collapse",
        "aria-label-position": "right"
      }
    });
    header.createSpan({ cls: "tree-item-icon collapse-icon" });
    header.createDiv({
      cls: "tree-item-inner",
      text: "CANVAS CONTAINED"
    });
    const canvases = await this.getCanvas(currentFile);
    header.createDiv({ cls: "tree-item-flair-outer" }, (el) => {
      el.createSpan({
        cls: "tree-item-flair",
        text: canvases.length.toString()
      });
    });
    if (isEmpty(canvases)) {
      return;
    }
    const content = body.createDiv({ cls: "search-result-container" });
    content.createDiv({
      attr: {
        "style": "width: 1px; height: 0.1px; margin-bottom: 0px;"
      }
    });
    for (const canvas of canvases) {
      content.createDiv({
        cls: "tree-item-self is-clickable outgoing-link-item",
        attr: { "draggable": true }
      }, (el) => {
        el.createSpan({ cls: "tree-item-icon" }, (el2) => {
          (0, import_obsidian.setIcon)(el2, "layout-dashboard");
        });
        el.createDiv({
          cls: "tree-item-inner",
          text: canvas.name.substring(0, canvas.name.lastIndexOf("."))
          // don't show path, like link view
        });
      }).addEventListener("click", () => {
        this.app.workspace.openLinkText("", canvas.path);
        this.selectedNodeId = canvas.selectedNodeId;
      });
      ;
    }
  }
  async getCanvas(currentFile) {
    const canvases = [];
    const files = this.app.vault.getFiles();
    for (const file of files) {
      if ("canvas" != file.extension) {
        continue;
      }
      const content = await this.app.vault.cachedRead(file);
      if (isEmpty(content)) {
        continue;
      }
      const nodes = JSON.parse(content).nodes;
      if (nodes == null) {
        continue;
      }
      for (const node of nodes) {
        if ("file" === node.type && currentFile.path === node.file) {
          const canvas = file;
          canvas.selectedNodeId = node.id;
          canvases.push(canvas);
          break;
        }
      }
    }
    canvases.sort((a, b) => asc(a.basename.toLowerCase(), b.basename.toLowerCase()));
    return canvases;
  }
  getFiles(currentFile, nodes) {
    const files = [];
    let nodeIds = [];
    for (const [key, value] of nodes) {
      if (value.file != null) {
        nodeIds.push(key);
        files.push(value.file);
      }
    }
    this.canvasNode.set(currentFile.path, nodeIds);
    files.sort((a, b) => asc(a.basename.toLowerCase(), b.basename.toLowerCase()));
    return files;
  }
};
function focus(canvas, node) {
  canvas.select(node);
  canvas.zoomToSelection();
}
function isEmpty(value) {
  if (typeof value === "string") {
    if (value && value.length > 0) {
      return false;
    } else {
      return true;
    }
  } else if (value instanceof Array) {
    if (value && value.length > 0) {
      return false;
    } else {
      return true;
    }
  }
  return true;
}
function asc(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}


/* nosourcemap */