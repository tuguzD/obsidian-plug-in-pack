/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AbbrPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");
var import_view2 = require("@codemirror/view");

// components/view.ts
var import_obsidian2 = require("obsidian");
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");

// common/data.ts
var abbrClassName = "abbreviations-plugin-abbr-element";
var extraDefinitionClassName = "abbreviations-plugin-extra-definition";
var extraAsteriskClassName = "abbreviations-plugin-extra-asterisk";
var elementListSelector = "p, li, h1, h2, h3, h4, h5, h6, th, td, .table-cell-wrapper, .callout-title-inner";
var METADATA_BORDER = "---";

// common/tool.ts
function isWhitespace(char) {
  return /\s/.test(char);
}
function isSpecialOrWhitespace(char) {
  if ("-" === char || "&" === char) {
    return false;
  }
  if (/\s/.test(char)) {
    return true;
  }
  if (/^[\p{L}\p{N}\p{Ideographic}]$/u.test(char)) {
    return false;
  }
  return true;
}
function isWord(text) {
  if (text === "") {
    return false;
  }
  for (const ch of text) {
    if (isSpecialOrWhitespace(ch)) {
      return false;
    }
  }
  return true;
}
function findCharCount(source, character) {
  if (source && character) {
    return source.split(character).length - 1;
  }
  return 0;
}
function getWords(text) {
  const result = [];
  let index = 0, lastState = true, tempStr = "";
  for (const char of text) {
    const state = isSpecialOrWhitespace(char);
    if (index === 0) {
      ++index;
      lastState = state;
      tempStr += char;
    } else if (lastState === state) {
      tempStr += char;
    } else {
      result.push({
        text: tempStr,
        isSpecial: lastState
      });
      lastState = state;
      tempStr = char;
      ++index;
    }
  }
  if (tempStr) {
    result.push({
      text: tempStr,
      isSpecial: lastState
    });
  }
  return result;
}
function parseExtraAbbreviation(line) {
  const matches = line.match(/^\*\[([^[\]]+?)\]:(\s+.*)?$/);
  if (matches) {
    return {
      key: matches[1],
      title: (matches[2] || "").trim()
    };
  }
  return null;
}
function isExtraDefinitions(text) {
  const lines = text.split("\n");
  let counter = 0;
  for (const line of lines) {
    if (line.match(/^\*\[[^[\]]+?\]:(\s+.*)?$/)) {
      counter = 0;
      continue;
    } else if (line.match(/^\[[^[\]]+?\]:(\s+.*)?$/)) {
      if (counter === 0) {
        counter = 1;
        continue;
      } else {
        counter = 0;
      }
    } else {
      return false;
    }
  }
  return counter === 0;
}
function getAffixList(affixes) {
  return Array.from(
    new Set(
      affixes.split(",").map((affix) => affix.trim()).filter((item) => item)
    )
  );
}
function getAbbreviationInstance(input) {
  if (typeof input === "string") {
    const val = input.trim();
    const index = val.indexOf(":");
    if (index > 0) {
      return {
        key: val.substring(0, index).trim(),
        title: val.substring(index + 1).trim(),
        type: "metadata"
      };
    }
  } else if (typeof input === "object" && input) {
    const keys = Object.keys(input);
    if (keys.length === 1 && typeof input[keys[0]] === "string") {
      return {
        key: keys[0],
        title: input[keys[0]],
        type: "metadata"
      };
    }
  }
  return null;
}
function queryAbbreviationTitle(text, abbrList, lineStart = 1, affixList = []) {
  let res = null;
  let affixRes = null;
  let detectAffixes = affixList.length > 0;
  for (let i = abbrList.length - 1; i >= 0; i--) {
    const abbr = abbrList[i];
    if (!abbr.key) {
      continue;
    }
    if (text === abbr.key) {
      res = abbr.title;
      if (abbr.type === "extra") {
        if (abbr.position <= lineStart) {
          break;
        }
      } else {
        break;
      }
    } else if (detectAffixes) {
      let match = false;
      for (const affix of affixList) {
        if (text === abbr.key + affix) {
          affixRes = abbr.title;
          match = true;
          break;
        }
      }
      if (match) {
        if (abbr.type === "extra") {
          if (abbr.position <= lineStart) {
            detectAffixes = false;
          }
        } else {
          detectAffixes = false;
        }
      }
    }
  }
  return res != null ? res : affixRes;
}
function isAbbreviationsEmpty(abbr) {
  if (abbr.length === 0) {
    return true;
  }
  const tempSet = /* @__PURE__ */ new Set();
  for (const item of abbr) {
    if (!item.key) {
      continue;
    }
    if (item.type === "extra") {
      return false;
    }
    if (item.title) {
      tempSet.add(item.key);
    } else {
      tempSet.delete(item.key);
    }
  }
  return tempSet.size === 0;
}
function calcAbbrListFromFrontmatter(frontmatter, keyword) {
  const abbrList = [];
  if (keyword && typeof frontmatter === "object" && frontmatter) {
    if (Array.isArray(frontmatter[keyword])) {
      const list = frontmatter[keyword];
      list.forEach((item) => {
        const abbrInfo = getAbbreviationInstance(item);
        abbrInfo && abbrList.push(abbrInfo);
      });
    }
  }
  return abbrList;
}

// components/dom.ts
function replaceWordWithAbbr(node, abbrList, lineStart = 1, affixList = []) {
  var _a;
  if (["DEL", "EM", "MARK", "STRONG"].includes(node.nodeName)) {
    const childNodes = node.childNodes;
    for (let i = 0; i < childNodes.length; i++) {
      replaceWordWithAbbr(childNodes[i], abbrList, lineStart, affixList);
    }
  }
  if (node.nodeType !== Node.TEXT_NODE) {
    return;
  }
  const text = node.textContent;
  if (text) {
    const fragment = document.createDocumentFragment();
    const words = getWords(text);
    words.forEach((word) => {
      if (word.isSpecial) {
        fragment.appendChild(document.createTextNode(word.text));
      } else {
        const abbrTitle = queryAbbreviationTitle(
          word.text,
          abbrList,
          lineStart,
          affixList
        );
        if (abbrTitle) {
          const abbr = fragment.createEl("abbr", {
            cls: abbrClassName,
            title: abbrTitle,
            text: word.text
          });
          fragment.appendChild(abbr);
        } else {
          fragment.appendChild(document.createTextNode(word.text));
        }
      }
    });
    (_a = node.parentNode) == null ? void 0 : _a.replaceChild(fragment, node);
  }
}
function handlePreviewMarkdown(element, abbrList, affixList = []) {
  if (isAbbreviationsEmpty(abbrList)) {
    return;
  }
  const eleList = element.findAll(elementListSelector);
  for (const ele of eleList) {
    const childNodes = ele.childNodes;
    for (let i = 0; i < childNodes.length; i++) {
      const node = childNodes[i];
      replaceWordWithAbbr(node, abbrList, 1, affixList);
    }
  }
}
function handlePreviewMarkdownExtra(context, element, abbrList, affixList = []) {
  if (isAbbreviationsEmpty(abbrList)) {
    return;
  }
  const pList = element.findAll(".markdown-preview-section > .el-p > p");
  for (const p of pList) {
    if (p.textContent && isExtraDefinitions(p.textContent)) {
      p.classList.add(extraDefinitionClassName);
    }
  }
  const eleList = element.findAll(elementListSelector);
  for (const ele of eleList) {
    if (ele.nodeName === "P" && ele.classList.contains(extraDefinitionClassName)) {
      continue;
    }
    const sectionInfo = context.getSectionInfo(ele);
    const lineStart = (sectionInfo == null ? void 0 : sectionInfo.lineStart) || 1;
    const childNodes = ele.childNodes;
    for (let i = 0; i < childNodes.length; i++) {
      const node = childNodes[i];
      replaceWordWithAbbr(node, abbrList, lineStart, affixList);
    }
  }
}

// common/base.ts
var Base = class {
  constructor() {
    this.state = "";
    this.codeBlocks = {
      graveCount: 0
    };
    this.quotes = {
      level: 0
    };
    this.lastEmptyLine = true;
  }
  isMetadataState() {
    return this.state === "metadata";
  }
};

// common/metadata.ts
var import_obsidian = require("obsidian");
function toMetadata(input) {
  if (typeof input === "object" && input) {
    return input;
  }
  return null;
}
function jsonParser(text) {
  try {
    const jsonObj = JSON.parse(text);
    return toMetadata(jsonObj);
  } catch (e) {
    return null;
  }
}
function yamlParser(text) {
  try {
    const yamlObj = (0, import_obsidian.parseYaml)(text);
    return toMetadata(yamlObj);
  } catch (e) {
    return null;
  }
}
function getMetadata(text) {
  let res = yamlParser(text);
  if (res === null) {
    res = jsonParser(text);
  }
  return res;
}

// common/parser.ts
var Parser = class extends Base {
  constructor(abbreviations, abbreviationKeyword, parseOption) {
    super();
    this.abbreviations = abbreviations.map(({ key, title }) => ({
      key,
      title,
      type: "global"
    })).filter((item) => item.key);
    this.abbreviationKeyword = abbreviationKeyword;
    this.parseOption = parseOption;
    this.metadataBuffer = [];
  }
  /**
   * Read abbreviations from frontmatter cache.
   * @param frontmatterCache
   */
  readAbbreviationsFromCache(frontmatterCache) {
    const list = calcAbbrListFromFrontmatter(
      frontmatterCache,
      this.abbreviationKeyword
    );
    this.abbreviations.push(...list);
  }
  /**
   * Determines whether the abbreviation list is empty.
   * @returns `true` if empty
   */
  isAbbreviationsEmpty() {
    return isAbbreviationsEmpty(this.abbreviations);
  }
  /**
   * Line content handler.
   * - Do not process Properties(Metadata), Code blocks, Math
   * - Process comments
   * @param text
   * @param lineStart
   */
  handler(text, lineStart) {
    if (lineStart === 1 && text === METADATA_BORDER) {
      this.state = "metadata";
      return;
    }
    if (this.quotes.level > 0) {
      if (this.state !== "math" && text.trim().length === 0) {
        this.state = "";
        this.codeBlocks.graveCount = 0;
        this.quotes.level = 0;
        this.lastEmptyLine = true;
        return;
      }
    }
    if (this.state === "") {
      if (this.lastEmptyLine) {
        if (/^[ ]{4,}|\t|[> ]+(?:[ ]{5,}|\t)/.test(text)) {
          return;
        }
      }
      const codeBlocks = text.match(/^([> ]*`{3,})[^`]*$/);
      if (codeBlocks) {
        this.state = "codeBlocks";
        this.codeBlocks.graveCount = findCharCount(codeBlocks[1], "`");
        this.quotes.level = findCharCount(codeBlocks[1], ">");
        return;
      }
      const math = text.match(/^([> ]*)\$\$(.*)/);
      if (math && !math[2].trim().endsWith("$$")) {
        this.state = "math";
        this.quotes.level = findCharCount(math[1], ">");
        return;
      }
      if (this.parseOption.extra) {
        const parseRes = parseExtraAbbreviation(text);
        if (parseRes) {
          this.abbreviations.push({
            key: parseRes.key,
            title: parseRes.title,
            type: "extra",
            position: lineStart
          });
        }
      }
    } else {
      if (this.state === "metadata") {
        if (text === METADATA_BORDER) {
          if (this.parseOption.metadata && this.abbreviationKeyword && this.metadataBuffer.length > 0) {
            const metadata = getMetadata(this.metadataBuffer.join("\n"));
            if (metadata) {
              const list = calcAbbrListFromFrontmatter(
                metadata,
                this.abbreviationKeyword
              );
              this.abbreviations.push(...list);
            }
          }
          this.state = "";
        } else if (this.parseOption.metadata && this.abbreviationKeyword) {
          this.metadataBuffer.push(text);
        }
      } else if (this.state === "codeBlocks") {
        const endCodeBlocks = text.match(/^([> ]*`{3,})([^`]*)$/);
        if (endCodeBlocks) {
          const level = findCharCount(endCodeBlocks[1], ">");
          if (level < this.quotes.level) {
            this.quotes.level = level;
            this.codeBlocks.graveCount = findCharCount(endCodeBlocks[1], "`");
          } else if (level === this.quotes.level && endCodeBlocks[2].trim().length === 0) {
            this.state = "";
          }
        }
      } else if (this.state === "math") {
        const endMath = text.match(/^([> ]*)\$\$/);
        if (endMath) {
          const level = findCharCount(endMath[1], ">");
          if (level < this.quotes.level) {
            this.quotes.level = level;
          } else if (level === this.quotes.level) {
            this.state = "";
          }
        }
      }
    }
  }
};

// common/mark.ts
var MarkBuffer = class {
  constructor() {
    this.grave = {
      isStart: false,
      startLen: 0,
      count: 0
    };
    this.link = {
      mode: "end",
      wait: "",
      openLen: 0,
      closeCount: 0,
      isInlineFootnote: false
    };
    this.init();
  }
  init() {
    this.marks = [];
    this.buffer = "";
    this.position = 0;
    this.mode = "separator";
    this.grave.isStart = false;
    this.grave.startLen = 0;
    this.grave.count = 0;
    this.link.mode = "end";
    this.link.wait = "";
    this.link.openLen = 0;
    this.link.closeCount = 0;
    this.link.isInlineFootnote = false;
  }
  charHandler(index, char) {
    if (this.mode === "inlineCode") {
      if (char === "`") {
        if (this.grave.isStart) {
          this.grave.startLen++;
        } else {
          this.grave.count++;
        }
        this.buffer += char;
      } else {
        this.grave.isStart = false;
        if (this.grave.startLen === this.grave.count) {
          this.mode = isSpecialOrWhitespace(char) ? "separator" : "word";
          this.grave.startLen = 0;
          this.grave.count = 0;
          this.buffer = char;
          this.position = index;
        } else {
          this.grave.count = 0;
          this.buffer += char;
        }
      }
    } else if (this.mode === "inlineMath") {
      if (char === "$" && !this.isPrefixEscape(-1, true)) {
        this.mode = "word";
        this.buffer = "";
        this.position = index + 1;
      } else {
        this.buffer += char;
      }
    } else if (this.mode === "link" && this.link.mode === "text" && (this.link.wait !== "URLOpen" || this.link.wait === "URLOpen" && char === "(")) {
      if (this.link.wait === "URLOpen" && char === "(") {
        this.link.wait = "URLClose";
      } else if (this.link.wait === "textClose" && char === "]" && !this.isPrefixEscape()) {
        this.link.wait = "";
        this.link.mode = "end";
      } else if (this.link.wait === "URLClose" && char === ")" && !this.isPrefixEscape()) {
        this.link.wait = "";
        this.link.mode = "end";
      } else if (char === "[" && !this.isPrefixEscape() && this.link.openLen === 1) {
        this.link.openLen = 2;
      } else if (char === "]" && !this.isPrefixEscape()) {
        this.link.closeCount++;
        if (this.link.openLen === 1 && this.link.closeCount === 1) {
          if (this.link.isInlineFootnote) {
            this.link.wait = "";
            this.link.mode = "end";
          } else {
            this.link.wait = "URLOpen";
          }
        } else if (this.link.openLen === 2 && this.link.closeCount === 1) {
          this.link.wait = "textClose";
        } else {
          this.link.mode = "end";
        }
      }
      this.buffer += char;
    } else {
      if (char === "`" && !this.isPrefixEscape()) {
        this.pushMark();
        this.mode = "inlineCode";
        this.grave.isStart = true;
        this.grave.startLen = 1;
        this.grave.count = 0;
        this.buffer = char;
        this.position = index;
      } else if (char === "$" && !this.isPrefixEscape()) {
        this.pushMark();
        this.mode = "inlineMath";
        this.buffer = char;
        this.position = index;
      } else if (char === "[" && !this.isPrefixEscape()) {
        this.pushMark();
        this.mode = "link";
        this.link.isInlineFootnote = this.buffer.at(-1) === "^" && !this.isPrefixEscape(-2);
        this.link.mode = "text";
        this.link.wait = "";
        this.link.openLen = 1;
        this.link.closeCount = 0;
        this.buffer = char;
        this.position = index;
      } else if (this.mode === "tag") {
        if ("-_/".indexOf(char) > -1) {
          this.buffer += char;
          return;
        }
        const state = isSpecialOrWhitespace(char);
        if (state) {
          this.mode = "separator";
          this.buffer = char;
          this.position = index;
        } else {
          this.buffer += char;
        }
      } else if (char === "#" && !this.isPrefixEscape()) {
        if (this.mode === "separator") {
          if (this.buffer.length === 0 || isWhitespace(this.buffer.at(-1) || "")) {
            this.mode = "tag";
            this.buffer = char;
            this.position = index;
          } else {
            this.buffer += char;
          }
        } else {
          this.pushMark();
          this.mode = "separator";
          this.buffer = char;
          this.position = index;
        }
      } else {
        const mode = isSpecialOrWhitespace(char) ? "separator" : "word";
        if (mode === this.mode) {
          this.buffer += char;
        } else {
          this.pushMark();
          this.mode = mode;
          this.buffer = char;
          this.position = index;
        }
      }
    }
  }
  pushMark() {
    if (this.mode === "word" && this.buffer.length > 0) {
      this.marks.push({
        text: this.buffer,
        position: this.position
      });
    }
  }
  /**
   * Whether the prefix is an escape character.
   * @param start start boundary. default: `-1`
   * @param onlyBit Check only one character. default: `false`
   * @returns `true` if the prefix is an escape character
   */
  isPrefixEscape(start = -1, onlyBit = false) {
    if (onlyBit) {
      return this.buffer.at(start) === "\\";
    }
    return this.buffer.at(start) === "\\" && this.buffer.at(start - 1) !== "\\";
  }
  handler(text) {
    this.init();
    for (let i = 0; i < text.length; i++) {
      this.charHandler(i, text[i]);
    }
    this.pushMark();
    return this.marks;
  }
};

// common/conversion.ts
var Conversion = class extends Base {
  constructor(abbreviations, skipExtraDefinition, affixList = []) {
    super();
    this.abbreviations = abbreviations;
    this.skipExtraDefinition = skipExtraDefinition;
    this.affixList = affixList;
    this.mark = new MarkBuffer();
  }
  /**
   * Line content handler.
   * - Do not process Properties(Metadata), Code blocks, Math
   * - Process Comments
   * @param text
   * @param lineStart
   * @param callback
   */
  handler(text, lineStart, callback) {
    if (lineStart === 1 && text === METADATA_BORDER) {
      this.state = "metadata";
      callback([], false);
      return;
    }
    if (this.quotes.level > 0) {
      if (this.state !== "math" && text.trim().length === 0) {
        this.state = "";
        this.codeBlocks.graveCount = 0;
        this.quotes.level = 0;
        this.lastEmptyLine = true;
        callback([], false);
        return;
      }
    }
    if (this.state === "") {
      if (this.lastEmptyLine) {
        if (/^[ ]{4,}|\t|[> ]+(?:[ ]{5,}|\t)/.test(text)) {
          callback([], false);
          return;
        }
      }
      const codeBlocks = text.match(/^([> ]*`{3,})[^`]*$/);
      if (codeBlocks) {
        this.state = "codeBlocks";
        this.codeBlocks.graveCount = findCharCount(codeBlocks[1], "`");
        this.quotes.level = findCharCount(codeBlocks[1], ">");
        callback([], false);
        return;
      }
      const math = text.match(/^([> ]*)\$\$(.*)/);
      if (math && !math[2].trim().endsWith("$$")) {
        this.state = "math";
        this.quotes.level = findCharCount(math[1], ">");
        callback([], false);
        return;
      }
      if (this.skipExtraDefinition) {
        const parseRes = parseExtraAbbreviation(text);
        if (parseRes) {
          callback([], true);
          return;
        }
      }
      const words = this.mark.handler(text);
      callback(
        words.map((word) => {
          const abbrTitle = queryAbbreviationTitle(
            word.text,
            this.abbreviations,
            lineStart,
            this.affixList
          );
          if (abbrTitle) {
            return {
              index: word.position,
              text: word.text,
              title: abbrTitle
            };
          }
          return null;
        }).filter((v) => v !== null),
        false
      );
      return;
    } else {
      if (this.state === "metadata") {
        if (text === METADATA_BORDER) {
          callback([], false);
          this.state = "";
          return;
        }
      } else if (this.state === "codeBlocks") {
        const endCodeBlocks = text.match(/^([> ]*`{3,})([^`]*)$/);
        if (endCodeBlocks) {
          const level = findCharCount(endCodeBlocks[1], ">");
          if (level < this.quotes.level) {
            this.quotes.level = level;
            this.codeBlocks.graveCount = findCharCount(endCodeBlocks[1], "`");
          } else if (level === this.quotes.level && endCodeBlocks[2].trim().length === 0) {
            this.state = "";
          }
        }
      } else if (this.state === "math") {
        const endMath = text.match(/^([> ]*)\$\$/);
        if (endMath) {
          const level = findCharCount(endMath[1], ">");
          if (level < this.quotes.level) {
            this.quotes.level = level;
          } else if (level === this.quotes.level) {
            this.state = "";
          }
        }
      }
    }
    callback([], false);
    return;
  }
};

// components/view.ts
var updateAbbrDecorations = import_state.StateEffect.define();
var abbrDecorationsField = import_state.StateField.define({
  create() {
    return import_view.Decoration.none;
  },
  update(decorations, tr) {
    for (const e of tr.effects) {
      if (e.is(updateAbbrDecorations)) {
        return e.value;
      }
    }
    return decorations.map(tr.changes);
  },
  provide: (f) => import_view.EditorView.decorations.from(f)
});
var updateEditorMode = import_state.StateEffect.define();
var editorModeField = import_state.StateField.define({
  create: () => false,
  update(value, tr) {
    for (const e of tr.effects) {
      if (e.is(updateEditorMode)) {
        return e.value;
      }
    }
    return value;
  }
});
var AbbrViewPlugin = class {
  constructor(view, getPluginData) {
    this.getPluginData = getPluginData;
    this.updateDecorations(view, view.state.field(import_obsidian2.editorLivePreviewField));
  }
  update(update) {
    if (update.docChanged || update.viewportChanged || update.transactions.some(
      (tr) => tr.effects.some((e) => e.is(updateEditorMode))
    )) {
      this.updateDecorations(
        update.view,
        update.state.field(import_obsidian2.editorLivePreviewField)
      );
    }
  }
  destroy() {
  }
  async updateDecorations(view, isLivePreviwMode) {
    const pluginData = await this.getPluginData();
    if (isLivePreviwMode || pluginData.markInSourceMode) {
      const builder = new import_state.RangeSetBuilder();
      const doc = view.state.doc;
      const parser = new Parser(
        pluginData.globalAbbreviations,
        pluginData.metadataKeyword,
        {
          metadata: true,
          extra: pluginData.useMarkdownExtraSyntax
        }
      );
      for (let i = 1; i < doc.lines + 1; i++) {
        const line = doc.line(i);
        const lineText = line.text;
        if (i === 1 && lineText !== METADATA_BORDER) {
          parser.readAbbreviationsFromCache(pluginData.frontmatterCache);
        }
        parser.handler(lineText, i);
        if (!pluginData.useMarkdownExtraSyntax && !parser.isMetadataState()) {
          break;
        }
      }
      if (!parser.isAbbreviationsEmpty()) {
        const conversion = new Conversion(
          parser.abbreviations,
          pluginData.useMarkdownExtraSyntax,
          pluginData.suffixes
        );
        for (let i = 1; i < doc.lines + 1; i++) {
          const line = doc.line(i);
          const lineText = line.text;
          conversion.handler(lineText, i, (markWords, isDefinition) => {
            if (isDefinition) {
              if (isLivePreviwMode) {
                const deco = import_view.Decoration.mark({
                  attributes: {
                    class: extraAsteriskClassName
                  }
                });
                builder.add(line.from, line.from + 1, deco);
              }
            } else {
              markWords.forEach((word) => {
                const from = line.from + word.index;
                const to = from + word.text.length;
                const deco = import_view.Decoration.mark({
                  tagName: "abbr",
                  attributes: {
                    text: word.text,
                    title: word.title,
                    class: abbrClassName
                  }
                });
                builder.add(from, to, deco);
              });
            }
          });
        }
      }
      const newDecorations = builder.finish();
      view.dispatch({
        effects: updateAbbrDecorations.of(newDecorations)
      });
      handlePreviewMarkdown(
        view.dom,
        parser.abbreviations,
        pluginData.suffixes
      );
    } else {
      view.dispatch({
        effects: updateAbbrDecorations.of(import_view.Decoration.none)
      });
    }
  }
};

// components/modal.ts
var import_obsidian3 = require("obsidian");
var AbbreviationInputModal = class extends import_obsidian3.Modal {
  constructor(app, selectedText, onSubmit) {
    super(app);
    this.selectedText = selectedText;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    let abbr = "", tip = "";
    const sText = this.selectedText.replace(/\n/, " ").trim();
    if (isWord(sText)) {
      abbr = sText;
    } else {
      tip = sText;
    }
    this.setTitle("Add abbreviation");
    const { contentEl } = this;
    new import_obsidian3.Setting(contentEl).setName("Abbreviation:").addText((text) => {
      text.setPlaceholder("Short word").setValue(abbr).onChange((value) => {
        abbr = value.trim();
      });
    }).addText((text) => {
      text.setPlaceholder("Tooltip").setValue(tip).onChange((value) => {
        tip = value.trim();
      });
    });
    new import_obsidian3.Setting(contentEl).addButton((btn) => {
      btn.setButtonText("Submit").setCta().onClick(() => {
        if (abbr) {
          this.close();
          this.onSubmit(abbr, tip);
        }
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// components/list.ts
var import_obsidian4 = require("obsidian");
var AbbreviationListModal = class extends import_obsidian4.FuzzySuggestModal {
  constructor(app, abbrList, selectedText, onSelect) {
    super(app);
    this.abbrList = abbrList;
    this.selectedText = selectedText;
    this.onSelete = onSelect;
    this.emptyStateText = "No abbreviations found.";
    this.setPlaceholder("Type the search term");
  }
  onOpen() {
    const sText = this.selectedText.replace(/\n/, " ").trim();
    this.inputEl.value = sText;
    this.inputEl.dispatchEvent(new InputEvent("input"));
  }
  getItems() {
    return this.abbrList;
  }
  getItemText(abbr) {
    return `${abbr.key}: ${abbr.title}`;
  }
  onChooseItem(abbr) {
    this.onSelete(abbr);
  }
  renderSuggestion(match, el) {
    el.createEl("div", { text: `${match.item.key}: ${match.item.title}` });
    el.createEl("small", {
      text: `type: ${match.item.type}` + (match.item.position ? ` - postion: ${match.item.position}` : "")
    });
  }
};

// common/format.ts
function lineMarkupFormatter(content, marks) {
  const results = [];
  let lastIndex = 0;
  marks.forEach((mark) => {
    if (mark.index > lastIndex) {
      results.push(content.substring(lastIndex, mark.index));
    }
    results.push(`<abbr title="${mark.title}">${mark.text}</abbr>`);
    lastIndex = mark.index + mark.text.length;
  });
  if (lastIndex < content.length) {
    results.push(content.substring(lastIndex));
  }
  return results.join("");
}
function contentFormatter(content, globalAbbreviations, metadataKeyword, useMarkdownExtraSyntax, affixList) {
  const results = [];
  const parser = new Parser(globalAbbreviations, metadataKeyword, {
    metadata: true,
    extra: useMarkdownExtraSyntax
  });
  const lines = content.split("\n");
  for (let i = 0; i < lines.length; i++) {
    const lineText = lines[i];
    const lineNum = i + 1;
    parser.handler(lineText, lineNum);
    if (!useMarkdownExtraSyntax && !parser.isMetadataState()) {
      break;
    }
  }
  const conversion = new Conversion(
    parser.abbreviations,
    useMarkdownExtraSyntax,
    affixList
  );
  let lastDefinitionState = false;
  for (let i = 0; i < lines.length; i++) {
    const lineText = lines[i];
    const lineNum = i + 1;
    conversion.handler(lineText, lineNum, (markWords, isDefinition) => {
      if (conversion.isMetadataState()) {
        return;
      }
      if (lineText === "") {
        if (lastDefinitionState && results.at(-1) === "") {
          lastDefinitionState = false;
          return;
        }
        results.push("");
        lastDefinitionState = false;
        return;
      }
      if (isDefinition) {
        lastDefinitionState = true;
        return;
      }
      if (markWords.length === 0) {
        results.push(lineText);
      } else {
        results.push(lineMarkupFormatter(lineText, markWords));
      }
      lastDefinitionState = false;
    });
  }
  return results.join("\n");
}

// main.ts
var DEFAULT_SETTINGS = {
  useMarkdownExtraSyntax: false,
  metadataKeyword: "abbr",
  detectAffixes: false,
  affixes: "",
  markInSourceMode: false,
  globalAbbreviations: []
};
var AbbrPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.debouncedSaveSettings = (0, import_obsidian5.debounce)(
      async () => {
        this.rerenderPreviewMarkdown();
      },
      1e3,
      true
    );
  }
  async onload() {
    await this.loadSettings();
    this.registerEditorExtension([
      abbrDecorationsField,
      editorModeField,
      this.createAbbrViewPlugin(this.getPluginData.bind(this))
    ]);
    this.registerMarkdownPostProcessor(async (element, context) => {
      var _a;
      if (this.settings.useMarkdownExtraSyntax) {
        const parser = new Parser(
          this.settings.globalAbbreviations,
          this.settings.metadataKeyword,
          {
            extra: true
          }
        );
        parser.readAbbreviationsFromCache(context.frontmatter);
        const file = this.app.workspace.getActiveFile();
        if (file) {
          const sourceContent = await this.app.vault.cachedRead(file);
          sourceContent.split("\n").forEach((line, index) => {
            parser.handler(line, index + 1);
          });
        }
        handlePreviewMarkdownExtra(
          context,
          element,
          parser.abbreviations,
          this.getAffixList()
        );
      } else {
        let frontmatter = context.frontmatter;
        if (this.settings.metadataKeyword) {
          if (!frontmatter) {
            if (element.classList.contains("table-cell-wrapper") || element.classList.contains("markdown-rendered")) {
              const file = this.app.workspace.getActiveFile();
              if (file) {
                frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
              }
            }
          }
        }
        const abbrList = this.getAbbrList(frontmatter);
        handlePreviewMarkdown(element, abbrList, this.getAffixList());
      }
    });
    this.registerEvent(
      this.app.metadataCache.on(
        "changed",
        (0, import_obsidian5.debounce)(
          (file) => {
            if (this.settings.metadataKeyword && file && file === this.app.workspace.getActiveFile()) {
              this.rerenderPreviewMarkdown(file);
            }
          },
          250,
          true
        )
      )
    );
    this.registerEvent(
      this.app.workspace.on(
        "active-leaf-change",
        this.handleModeChange.bind(this)
      )
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", this.handleModeChange.bind(this))
    );
    this.addCommand({
      id: "add-abbreviation",
      name: "Add abbreviation",
      editorCheckCallback: (checking) => {
        const keywordState = this.settings.metadataKeyword;
        if (keywordState) {
          if (!checking) {
            this.showAbbreviationInputModal();
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "copy-with-format",
      name: "Copy and format content",
      callback: () => {
        this.copyAndFormatContent();
      }
    });
    this.addCommand({
      id: "insert-extra-definition",
      name: "Insert extra definition",
      editorCheckCallback: (checking) => {
        const extraState = this.settings.useMarkdownExtraSyntax;
        if (extraState) {
          if (!checking) {
            this.insertExtraDefinition();
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "list-abbreviations",
      name: "List abbreviations",
      editorCallback: () => {
        this.showAbbreviationListModal();
      }
    });
    this.addCommand({
      id: "manage-global-abbreviations",
      name: "Manage global abbreviations",
      callback: () => {
        this.showManageAbbreviationsModal();
      }
    });
    this.addRibbonIcon("text-search", "List abbreviations", () => {
      this.showAbbreviationListModal();
    });
    this.addSettingTab(new AbbrSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.debouncedSaveSettings();
  }
  createAbbrViewPlugin(getPluginData) {
    return import_view2.ViewPlugin.fromClass(
      class extends AbbrViewPlugin {
        constructor(view) {
          super(view, getPluginData);
        }
      }
    );
  }
  handleModeChange() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (view) {
      const isLivePreview = view.getMode() === "source";
      const cmEditor = view.editor.cm;
      if (cmEditor) {
        cmEditor.dispatch({
          effects: updateEditorMode.of(isLivePreview)
        });
      }
    }
  }
  getAbbrList(frontmatter) {
    const abbrList = this.settings.globalAbbreviations.map(({ key, title }) => ({
      key,
      title,
      type: "global"
    })).filter((item) => item.key);
    const readList = calcAbbrListFromFrontmatter(
      frontmatter,
      this.settings.metadataKeyword
    );
    abbrList.push(...readList);
    return abbrList;
  }
  /**
   * Rerender Preview Markdown.
   * @param file
   */
  rerenderPreviewMarkdown(file) {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (view) {
      if (!file || file === view.file) {
        view.previewMode.rerender(true);
      }
    }
  }
  async getPluginData() {
    var _a;
    const { metadataKeyword, ...other } = this.settings;
    const data = {
      metadataKeyword,
      frontmatterCache: void 0,
      suffixes: this.getAffixList(),
      ...other
    };
    if (metadataKeyword) {
      const file = this.app.workspace.getActiveFile();
      if (file) {
        data.frontmatterCache = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      }
    }
    return data;
  }
  getAffixList() {
    return this.settings.detectAffixes ? getAffixList(this.settings.affixes) : void 0;
  }
  async copyAndFormatContent() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      const content = await this.app.vault.cachedRead(activeFile);
      const formatContent = contentFormatter(
        content,
        this.settings.globalAbbreviations,
        this.settings.metadataKeyword,
        this.settings.useMarkdownExtraSyntax,
        this.getAffixList()
      );
      try {
        await navigator.clipboard.writeText(formatContent);
        this.sendNotification("Formatted content has been copied!");
      } catch (e) {
        this.sendNotification("Error: Unable to copy content!");
      }
    }
  }
  insertExtraDefinition() {
    var _a;
    const editor = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor;
    if (editor) {
      const selectedText = editor.getSelection();
      const content = selectedText ? `*[${selectedText}]: ` : "*[]: ";
      const cursor = editor.getCursor();
      if (selectedText) {
        editor.replaceSelection(content);
      } else {
        editor.replaceRange(content, cursor);
      }
      editor.setCursor({
        line: cursor.line,
        ch: cursor.ch + (selectedText ? selectedText.length + 5 : 2)
      });
    }
  }
  showAbbreviationInputModal() {
    var _a;
    const editor = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor;
    if (editor) {
      const selectedText = editor.getSelection();
      new AbbreviationInputModal(
        this.app,
        selectedText,
        this.addAbbreviationToFrontmatter.bind(this)
      ).open();
    }
  }
  async showAbbreviationListModal() {
    var _a, _b;
    let abbrList = [];
    let selectedText = "";
    const file = this.app.workspace.getActiveFile();
    if (file) {
      const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if (this.settings.useMarkdownExtraSyntax) {
        const parser = new Parser(
          this.settings.globalAbbreviations,
          this.settings.metadataKeyword,
          {
            extra: true
          }
        );
        parser.readAbbreviationsFromCache(frontmatter);
        const sourceContent = await this.app.vault.cachedRead(file);
        sourceContent.split("\n").forEach((line, index) => {
          parser.handler(line, index + 1);
        });
        abbrList = parser.abbreviations;
      } else {
        abbrList = this.getAbbrList(frontmatter);
      }
      const editor = (_b = this.app.workspace.activeEditor) == null ? void 0 : _b.editor;
      if (editor) {
        selectedText = editor.getSelection();
      }
      new AbbreviationListModal(
        this.app,
        abbrList,
        selectedText,
        this.jumpToAbbreviationDefinition.bind(this)
      ).open();
    }
  }
  showManageAbbreviationsModal() {
    new AbbreviationManagerModal(this.app, this).open();
  }
  addAbbreviationToFrontmatter(abbr, tooltip) {
    if (!isWord(abbr)) {
      this.sendNotification("Warn: Abbreviation format is incorrect!");
      return;
    }
    const metadataKeyword = this.settings.metadataKeyword;
    if (metadataKeyword) {
      const file = this.app.workspace.getActiveFile();
      if (file) {
        this.app.fileManager.processFrontMatter(file, (frontmatter) => {
          if (typeof frontmatter === "object" && frontmatter) {
            const item = `${abbr}: ${tooltip}`;
            if (Array.isArray(frontmatter[metadataKeyword])) {
              frontmatter[metadataKeyword].push(item);
            } else {
              frontmatter[metadataKeyword] = [item];
            }
          } else {
            this.sendNotification("Error: Unexpected error!");
          }
        });
      } else {
        this.sendNotification("Error: No active file found!");
      }
    } else {
      this.sendNotification("Error: Metadata keyword is empty!");
    }
  }
  jumpToAbbreviationDefinition(abbr) {
    var _a;
    if (abbr.type === "global") {
      this.showManageAbbreviationsModal();
    } else {
      const editor = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor;
      if (editor) {
        if (abbr.type === "metadata") {
          editor.setCursor(1);
        } else if (abbr.type === "extra") {
          const dest = abbr.position - 1;
          editor.setCursor(dest >= 0 ? dest : 0);
        }
      }
    }
  }
  sendNotification(message) {
    new import_obsidian5.Notice(message);
  }
};
var AbbrSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const metadataKeywordSetting = new import_obsidian5.Setting(containerEl).setName("Metadata keyword").addText(
      (text) => text.setPlaceholder("Enter the keyword").setValue(this.plugin.settings.metadataKeyword).onChange(async (value) => {
        this.plugin.settings.metadataKeyword = value.trim();
        await this.plugin.saveSettings();
      })
    );
    const metadataKeywordDesc = document.createDocumentFragment();
    metadataKeywordDesc.append(
      "The key name that reads the abbreviation information from the ",
      createEl("a", {
        href: "https://help.obsidian.md/Editing+and+formatting/Properties",
        text: "properties"
      }),
      "."
    );
    metadataKeywordSetting.descEl.appendChild(metadataKeywordDesc);
    const useMarkdownExtraSyntaxSetting = new import_obsidian5.Setting(containerEl).setName("Enable Markdown Extra syntax support (Experimental)").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useMarkdownExtraSyntax).onChange(async (value) => {
        this.plugin.settings.useMarkdownExtraSyntax = value;
        await this.plugin.saveSettings();
      });
    });
    const useMarkdownExtraSyntaxDesc = document.createDocumentFragment();
    useMarkdownExtraSyntaxDesc.append(
      "Toggle this setting to enable or disable the feature. Definition format: ",
      createEl("b", {
        text: "*[W3C]: World Wide Web Consortium"
      }),
      "."
    );
    useMarkdownExtraSyntaxSetting.descEl.appendChild(
      useMarkdownExtraSyntaxDesc
    );
    new import_obsidian5.Setting(containerEl).setName("Mark abbreviations in Source mode").setDesc(
      "In Source mode, mark abbreviations just like in Live Preview and Reading view."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.markInSourceMode).onChange(async (value) => {
        this.plugin.settings.markInSourceMode = value;
        await this.plugin.saveSettings();
      });
    });
    const globalAbbreviationsSetting = new import_obsidian5.Setting(containerEl).setName("Global abbreviations").addButton((button) => {
      button.setButtonText("Manage abbreviations").onClick(() => {
        this.displayGlobalAbbreviations();
      });
    });
    const globalAbbreviationsDesc = document.createDocumentFragment();
    globalAbbreviationsDesc.append(
      "Configure global abbreviations, but their priority is lower than ",
      createEl("a", {
        href: "https://help.obsidian.md/Editing+and+formatting/Properties",
        text: "properties"
      }),
      "."
    );
    globalAbbreviationsSetting.descEl.appendChild(globalAbbreviationsDesc);
    new import_obsidian5.Setting(containerEl).setName("Suffixes").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Enable detect suffixes").setDesc("Detect supplementary suffixes for abbreviations.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.detectAffixes).onChange(async (value) => {
        this.plugin.settings.detectAffixes = value;
        await this.plugin.saveSettings();
      });
    });
    const affixesSetting = new import_obsidian5.Setting(containerEl).setName("Suffix list").addText((text) => {
      text.setPlaceholder("A string separated by ,").setValue(this.plugin.settings.affixes).onChange(async (value) => {
        this.plugin.settings.affixes = value.trim();
        await this.plugin.saveSettings();
      });
    });
    const affixesDesc = document.createDocumentFragment();
    affixesDesc.append(
      "The list content uses comma-separated string, for example: ",
      createEl("b", {
        text: "s, es, less"
      }),
      "."
    );
    affixesSetting.descEl.appendChild(affixesDesc);
  }
  displayGlobalAbbreviations() {
    const { containerEl } = this;
    manageGlobalAbbreviations(this.plugin, containerEl, () => {
      new import_obsidian5.Setting(containerEl).setName("Global abbreviations").setHeading().addButton((button) => {
        button.setButtonText("Back").onClick(() => {
          this.display();
        });
      });
    });
  }
};
var AbbreviationManagerModal = class extends import_obsidian5.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    manageGlobalAbbreviations(this.plugin, contentEl, () => {
      this.setTitle("Manage global abbreviations");
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
function manageGlobalAbbreviations(plugin, containerEl, header) {
  containerEl.empty();
  header();
  plugin.settings.globalAbbreviations.forEach((abbr, index) => {
    new import_obsidian5.Setting(containerEl).setName("Abbreviation:").addText(
      (text) => text.setPlaceholder("Short word").setValue(abbr.key).onChange(async (value) => {
        plugin.settings.globalAbbreviations[index].key = value.trim();
        await plugin.saveSettings();
      })
    ).addText(
      (text) => text.setPlaceholder("Tooltip").setValue(abbr.title).onChange(async (value) => {
        plugin.settings.globalAbbreviations[index].title = value.trim();
        await plugin.saveSettings();
      })
    ).addButton(
      (button) => button.setButtonText("Delete").onClick(async () => {
        plugin.settings.globalAbbreviations.splice(index, 1);
        await plugin.saveSettings();
        manageGlobalAbbreviations(plugin, containerEl, header);
      })
    );
  });
  new import_obsidian5.Setting(containerEl).addButton(
    (button) => button.setButtonText("Add").setTooltip("Add new abbreviation").onClick(async () => {
      plugin.settings.globalAbbreviations.push({
        key: "",
        title: ""
      });
      await plugin.saveSettings();
      manageGlobalAbbreviations(plugin, containerEl, header);
    })
  );
}
//! `-` and `&` not considered a special character
//! empty line
//! Delay trigger rerender
//! Rerender

/* nosourcemap */