/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);

// src/plugin.ts
var import_obsidian2 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var KeyLabelOverrides = {
  ArrowUp: "Up",
  ArrowLeft: "Left",
  ArrowDown: "Down",
  ArrowRight: "Right"
};
var CanvasKeyboardPanSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.app = app;
    this.plugin = plugin;
    this.keySettingsListener = null;
    this.activeDirection = null;
    this.keys = {};
  }
  display() {
    this.containerEl.empty();
    const keyboardViewContainer = this.containerEl.createDiv();
    keyboardViewContainer.appendChild(this.renderKeyboardView(this.plugin.settings.keys, null));
    new import_obsidian.Setting(this.containerEl).setName("Controls").setDesc("Which set of keys pan the canvas.").addExtraButton((button) => {
      button.setIcon("rotate-ccw");
      button.setTooltip("Restore default");
      button.onClick(async () => {
        this.plugin.settings.keys = { ...DEFAULT_SETTINGS.keys };
        await this.plugin.saveData(this.plugin.settings);
        this.display();
      });
    }).addButton((button) => {
      button.setButtonText("Update controls");
      button.onClick(() => {
        this.activeDirection = "north" /* North */;
        this.keys = {};
        keyboardViewContainer.empty();
        keyboardViewContainer.appendChild(this.renderKeyboardView(this.keys, this.activeDirection));
        const listener = ((evt) => {
          if (this.activeDirection === null) {
            return;
          }
          this.keys[this.activeDirection] = evt.key;
          switch (this.activeDirection) {
            case "north" /* North */:
              this.activeDirection = "west" /* West */;
              break;
            case "west" /* West */:
              this.activeDirection = "south" /* South */;
              break;
            case "south" /* South */:
              this.activeDirection = "east" /* East */;
              break;
            case "east" /* East */:
              this.activeDirection = null;
              void this.saveKeys(this.keys);
              break;
          }
          keyboardViewContainer.empty();
          keyboardViewContainer.appendChild(this.renderKeyboardView(this.keys, this.activeDirection));
        }).bind(this);
        this.keySettingsListener = listener;
        this.plugin.registerDomEvent(document, "keydown", listener);
      });
    });
    new import_obsidian.Setting(this.containerEl).setName("Maximum pan speed").setDesc("Canvas units to pan by").addExtraButton((button) => {
      button.setIcon("rotate-ccw");
      button.setTooltip("Restore default");
      button.onClick(async () => {
        this.plugin.settings.maxSpeed = DEFAULT_SETTINGS.maxSpeed;
        await this.plugin.saveData(this.plugin.settings);
        this.display();
      });
    }).addSlider((slider) => {
      var _a;
      const displayValue = createSpan({ text: this.plugin.settings.maxSpeed.toString() });
      (_a = slider.sliderEl.parentElement) == null ? void 0 : _a.prepend(displayValue);
      slider.setLimits(50, 500, 10);
      slider.setValue(this.plugin.settings.maxSpeed);
      slider.onChange((value) => {
        displayValue.setText(value.toString());
        this.plugin.settings.maxSpeed = value;
        void this.plugin.saveData(this.plugin.settings);
      });
    });
  }
  async saveKeys(keys) {
    if (!keys["north" /* North */] || !keys["west" /* West */] || !keys["south" /* South */] || !keys["east" /* East */]) {
      return;
    }
    this.plugin.settings = {
      ...this.plugin.settings,
      keys: { ...keys }
    };
    await this.plugin.saveData(this.plugin.settings);
    if (this.keySettingsListener) {
      document.removeEventListener("keydown", this.keySettingsListener);
      this.keySettingsListener = null;
    }
    this.display();
  }
  renderKeyboardView(keys, activeKey) {
    const container = createDiv({ cls: "pan-kb-mapping-container" });
    const icons = {
      ["north" /* North */]: container.createDiv({ cls: ["pan-kb", "pan-kb-north"] }),
      ["west" /* West */]: container.createDiv({ cls: ["pan-kb", "pan-kb-west"] }),
      ["south" /* South */]: container.createDiv({ cls: ["pan-kb", "pan-kb-south"] }),
      ["east" /* East */]: container.createDiv({ cls: ["pan-kb", "pan-kb-east"] })
    };
    (0, import_obsidian.setIcon)(icons.north, "lucide-arrow-up-square");
    (0, import_obsidian.setIcon)(icons.west, "lucide-arrow-left-square");
    (0, import_obsidian.setIcon)(icons.south, "lucide-arrow-down-square");
    (0, import_obsidian.setIcon)(icons.east, "lucide-arrow-right-square");
    const labels = {
      ["north" /* North */]: container.createDiv({
        cls: ["pan-kb-label", "pan-kb-label-north"],
        text: this.getKeyLabel(keys, "north" /* North */)
      }),
      ["west" /* West */]: container.createDiv({
        cls: ["pan-kb-label", "pan-kb-label-west"],
        text: this.getKeyLabel(keys, "west" /* West */)
      }),
      ["south" /* South */]: container.createDiv({
        cls: ["pan-kb-label", "pan-kb-label-south"],
        text: this.getKeyLabel(keys, "south" /* South */)
      }),
      ["east" /* East */]: container.createDiv({
        cls: ["pan-kb-label", "pan-kb-label-east"],
        text: this.getKeyLabel(keys, "east" /* East */)
      })
    };
    if (activeKey !== null) {
      icons[activeKey].classList.add("active");
      labels[activeKey].classList.add("active");
    }
    return container;
  }
  getKeyLabel(keys, direction) {
    var _a, _b;
    const key = (_a = keys[direction]) != null ? _a : "?";
    return (_b = KeyLabelOverrides[key]) != null ? _b : key;
  }
};

// src/util.ts
function xor(a, b) {
  return a && !b || b && !a;
}

// src/plugin.ts
var DEFAULT_SETTINGS = {
  keys: {
    ["north" /* North */]: "w",
    ["west" /* West */]: "a",
    ["south" /* South */]: "s",
    ["east" /* East */]: "d"
  },
  maxSpeed: 250
};
var CanvasKeyboardPan = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    // Settings
    this.settings = {
      keys: { ...DEFAULT_SETTINGS.keys },
      maxSpeed: DEFAULT_SETTINGS.maxSpeed
    };
    // State
    this.PanStart = null;
    this.NorthKeyDown = false;
    this.EastKeyDown = false;
    this.SouthKeyDown = false;
    this.WestKeyDown = false;
    this.active = false;
    this.panInterval = void 0;
  }
  async onload() {
    const data = await this.loadData();
    if (data) {
      this.settings = { ...DEFAULT_SETTINGS, ...data };
    }
    this.addSettingTab(new CanvasKeyboardPanSettingsTab(this.app, this));
    this.registerDomEvent(this.app.workspace.containerEl, "keydown", (evt) => {
      if (this.app.workspace.activeEditor) {
        return;
      }
      if (Object.values(this.settings.keys).includes(evt.key)) {
        switch (evt.key) {
          case this.settings.keys["north" /* North */]:
            this.NorthKeyDown = true;
            this.SouthKeyDown = false;
            break;
          case this.settings.keys["west" /* West */]:
            this.WestKeyDown = true;
            this.EastKeyDown = false;
            break;
          case this.settings.keys["south" /* South */]:
            this.SouthKeyDown = true;
            this.NorthKeyDown = false;
            break;
          case this.settings.keys["east" /* East */]:
            this.EastKeyDown = true;
            this.WestKeyDown = false;
            break;
        }
        this.startPan();
      }
    });
    this.registerDomEvent(this.app.workspace.containerEl, "keyup", (evt) => {
      if (Object.values(this.settings.keys).includes(evt.key)) {
        switch (evt.key) {
          case this.settings.keys["north" /* North */]:
            this.NorthKeyDown = false;
            break;
          case this.settings.keys["west" /* West */]:
            this.WestKeyDown = false;
            break;
          case this.settings.keys["south" /* South */]:
            this.SouthKeyDown = false;
            break;
          case this.settings.keys["east" /* East */]:
            this.EastKeyDown = false;
            break;
        }
        this.stopPan();
      }
    });
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => {
    }));
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.stopPan(true);
        if (this.getActiveCanvas()) {
          this.active = true;
        } else {
          this.active = false;
        }
      })
    );
    const events = ["active-leaf-change", "file-open", "file-menu", "files-menu"];
    for (const event of events) {
      this.registerEvent(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Some bad types here, need to use any :(
        this.app.workspace.on(event, () => {
          this.stopPan(true);
        })
      );
    }
  }
  startPan() {
    if (this.panInterval === void 0) {
      this.panInterval = this.registerInterval(window.setInterval(() => this.handlePanKeys(), 10));
    }
  }
  stopPan(force = false) {
    if (!this.panning || force) {
      window.clearInterval(this.panInterval);
      this.panInterval = void 0;
    }
    if (force) {
      this.NorthKeyDown = false;
      this.WestKeyDown = false;
      this.SouthKeyDown = false;
      this.EastKeyDown = false;
    }
  }
  get panning() {
    return xor(this.EastKeyDown, this.WestKeyDown) || xor(this.NorthKeyDown, this.SouthKeyDown);
  }
  getActiveCanvas() {
    var _a;
    const canvas = (_a = this.app.workspace.getActiveViewOfType(import_obsidian2.ItemView)) == null ? void 0 : _a.canvas;
    if (!canvas) {
      this.stopPan();
    }
    return canvas;
  }
  handlePanKeys() {
    let ms = 0;
    if (this.PanStart === null) {
      this.PanStart = new Date();
    } else {
      ms = new Date().getTime() - this.PanStart.getTime();
    }
    let dx = 0;
    let dy = 0;
    if (this.NorthKeyDown && !this.SouthKeyDown) {
      dy -= this.getPanDistance(ms, this.settings.maxSpeed);
    } else if (this.SouthKeyDown && !this.NorthKeyDown) {
      dy += this.getPanDistance(ms, this.settings.maxSpeed);
    }
    if (this.WestKeyDown && !this.EastKeyDown) {
      dx -= this.getPanDistance(ms, this.settings.maxSpeed);
    } else if (this.EastKeyDown && !this.WestKeyDown) {
      dx += this.getPanDistance(ms, this.settings.maxSpeed);
    }
    this.pan(dx, dy);
  }
  pan(dx, dy) {
    var _a;
    const canvas = this.getActiveCanvas();
    if (!canvas) {
      return;
    }
    const zoom = ((_a = canvas.zoom) != null ? _a : -4) + 5;
    dx = dx / zoom;
    dy = dy / zoom;
    canvas.tx += dx;
    canvas.ty += dy;
    if (isNaN(canvas.tx)) {
      canvas.tx = 0;
    }
    if (isNaN(canvas.ty)) {
      canvas.ty = 0;
    }
    canvas.markViewportChanged();
  }
  getPanDistance(msPanning = 0, max = 250) {
    if (msPanning < 1) {
      return 0;
    }
    return Math.min(Math.log10(msPanning) * max / 3, 250);
  }
  resetCanvas() {
    var _a;
    (_a = this.getActiveCanvas()) == null ? void 0 : _a.panTo(0, 0);
  }
};

// main.ts
var main_default = CanvasKeyboardPan;

/* nosourcemap */