/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GestureNav
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  trigerkey: 2 /* RIGHT_CLICK */,
  enableDrawing: true,
  strokeColor: "accent",
  customStrokeColor: "",
  lineWidth: 5
};
var isPreviewMode = (markdownView) => {
  if (markdownView === null)
    return false;
  const mode = markdownView.getMode();
  return mode === "preview" && markdownView.previewMode !== null;
};
var isEditMode = (markdownView) => {
  if (markdownView === null)
    return false;
  const mode = markdownView.getMode();
  return mode === "source" && markdownView.editor !== null;
};
var globalMouseDown = false;
var GestureNav = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.overlay = null;
    // Declare overlay at the class level
    this.currentGesture = null;
    // Declare currentGesture at the class level
    this.canvas = null;
    this.ctx = null;
    this.drawing = false;
    this.scrollToBottom = async () => {
      const markdownView = this.getCurrentViewOfType();
      if (markdownView === null)
        return;
      markdownView.currentMode.applyScroll(Number.MAX_SAFE_INTEGER);
    };
  }
  async onload() {
    await this.loadSettings();
    this.registerEvent(
      this.app.workspace.on(
        "window-open",
        (newWindow) => this.registerEvents(newWindow.win)
      )
    );
    this.registerEvents(window);
    this.addSettingTab(new GestureNavSettingTab(this.app, this));
  }
  onunload() {
    if (this.canvas) {
      document.body.removeChild(this.canvas);
      this.canvas = null;
      this.ctx = null;
    }
    if (this.overlay) {
      this.overlay.remove();
      this.overlay = null;
    }
    this.drawing = false;
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Keep track if we are currently drawing
  registerEvents(currentWindow) {
    const doc = currentWindow.document;
    function preventDefault(event) {
      var _a;
      const target = event.target;
      if ((_a = target.closest(".workspace-leaf")) == null ? void 0 : _a.classList.contains("nav-folder")) {
        return;
      }
      if (event.isTrusted) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
    let startClientX = 0;
    let startClientY = 0;
    const gesture_margin = 75;
    this.registerDomEvent(doc, "mousedown", (evt) => {
      if (this.isSettingsVisible()) {
        return;
      }
      if (evt.button === this.settings.trigerkey) {
        if (isEditMode(this.getCurrentViewOfType())) {
          doc.addEventListener("contextmenu", preventDefault, true);
          this.startDrawing(evt);
          globalMouseDown = true;
          startClientX = evt.clientX;
          startClientY = evt.clientY;
          this.currentGesture = null;
        } else {
          doc.removeEventListener("contextmenu", preventDefault, true);
        }
      }
    });
    this.registerDomEvent(doc, "mousemove", (evt) => {
      if (this.drawing) {
        this.draw(evt.clientX, evt.clientY);
      }
      if (globalMouseDown) {
        const deltaX = evt.clientX - startClientX;
        const deltaY = evt.clientY - startClientY;
        let detectedGesture = null;
        if (Math.abs(deltaX) > gesture_margin && Math.abs(deltaY) < gesture_margin) {
          detectedGesture = deltaX > 0 ? "right" : "left";
        } else if (Math.abs(deltaY) > gesture_margin && Math.abs(deltaX) < gesture_margin) {
          detectedGesture = deltaY > 0 ? "down" : "up";
        }
        if (detectedGesture !== this.currentGesture) {
          this.currentGesture = detectedGesture;
          this.showGestureOverlay(this.currentGesture);
        }
      }
    });
    this.registerDomEvent(doc, "mouseup", (evt) => {
      this.stopDrawing();
      if (evt.button === this.settings.trigerkey) {
        globalMouseDown = false;
        if (this.currentGesture === "right") {
          this.executeGestureAction(
            "right",
            () => window.history.forward()
          );
        } else if (this.currentGesture === "left") {
          this.executeGestureAction(
            "left",
            () => window.history.back()
          );
        } else if (this.currentGesture === "down") {
          this.executeGestureAction(
            "down",
            this.scrollToBottom.bind(this)
          );
        } else if (this.currentGesture === "up") {
          this.executeGestureAction(
            "up",
            this.scrollToTop.bind(this)
          );
        } else {
          this.showContextMenu(evt);
        }
        this.currentGesture = null;
        if (this.overlay) {
          this.overlay.remove();
        }
      }
    });
  }
  startDrawing(evt) {
    if (!this.settings.enableDrawing) {
      return;
    }
    this.drawing = true;
    if (!this.canvas) {
      this.canvas = document.createElement("canvas");
      this.canvas.classList.add("gesture-canvas");
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
      document.body.appendChild(this.canvas);
      this.ctx = this.canvas.getContext("2d");
      let strokeColor = this.settings.strokeColor;
      if (strokeColor === "accent") {
        const obsidianStyles = getComputedStyle(document.body);
        strokeColor = obsidianStyles.getPropertyValue("--interactive-accent").trim();
      } else if (strokeColor === "custom") {
        strokeColor = this.settings.customStrokeColor || "#000000";
      }
      if (this.ctx) {
        this.ctx.strokeStyle = strokeColor;
        this.ctx.lineWidth = this.settings.lineWidth;
        this.ctx.lineJoin = "round";
        this.ctx.lineCap = "round";
      }
    }
    if (this.ctx) {
      this.ctx.beginPath();
      this.ctx.moveTo(evt.clientX, evt.clientY);
    }
  }
  // Draw the line to the current mouse position
  draw(x, y) {
    if (!this.drawing || !this.settings.enableDrawing) {
      return;
    }
    if (this.ctx) {
      this.ctx.lineTo(x, y);
      this.ctx.stroke();
    }
  }
  // Stop drawing and remove the canvas if necessary
  stopDrawing() {
    if (!this.settings.enableDrawing) {
      return;
    }
    this.drawing = false;
    if (this.canvas) {
      document.body.removeChild(this.canvas);
      this.canvas = null;
      this.ctx = null;
    }
  }
  // Execute gesture actions and show the overlay
  executeGestureAction(gesture, action) {
    this.showGestureOverlay(gesture);
    action();
  }
  showContextMenu(evt) {
    const markdownView = this.getCurrentViewOfType();
    if (isEditMode(markdownView)) {
      this.showEditModeContextMenu(evt);
    } else if (isPreviewMode(markdownView)) {
      this.showPreviewContextMenu(evt);
    }
  }
  showEditModeContextMenu(evt) {
    const doc = document;
    doc.elementFromPoint(evt.clientX, evt.clientY).dispatchEvent(
      new MouseEvent("contextmenu", {
        bubbles: true,
        cancelable: true,
        clientX: evt.clientX,
        clientY: evt.clientY
      })
    );
  }
  isSettingsVisible() {
    const settingTabs = document.querySelector(".modal-container");
    return settingTabs !== null && settingTabs.style.display !== "none";
  }
  selectTextUnderCursor(evt) {
  }
  showPreviewContextMenu(evt) {
  }
  showGestureOverlay(gesture) {
    if (this.overlay) {
      this.overlay.remove();
    }
    this.overlay = document.createElement("div");
    this.overlay.classList.add("gesture-overlay");
    let arrowSymbol = "";
    let actionText = "";
    if (gesture === "right") {
      arrowSymbol = "\u2192";
      actionText = "Next page";
    } else if (gesture === "left") {
      arrowSymbol = "\u2190";
      actionText = "Previous page";
    } else if (gesture === "up") {
      arrowSymbol = "\u2191";
      actionText = "Scroll to top";
    } else if (gesture === "down") {
      arrowSymbol = "\u2193";
      actionText = "Scroll to bottom";
    } else {
      arrowSymbol = "\u2715";
      this.overlay.classList.add("gesture-overlay-cancel");
    }
    const arrow = document.createElement("div");
    arrow.innerText = arrowSymbol;
    this.overlay.appendChild(arrow);
    const text = document.createElement("div");
    text.innerText = actionText;
    text.classList.add("gesture-text");
    this.overlay.appendChild(text);
    document.body.appendChild(this.overlay);
  }
  getCurrentViewOfType() {
    let markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    return markdownView;
  }
  scrollToTop() {
    const markdownView = this.getCurrentViewOfType();
    if (markdownView === null)
      return;
    markdownView.currentMode.applyScroll(0);
  }
};
var GestureNavSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Triger mouse key").setDesc("Select the mouse key to trigger the gesture").addDropdown(
      (dropdown) => dropdown.addOptions({
        [2 /* RIGHT_CLICK */]: "Right click"
        // [TrigerKey.WHEEL_CLICK]: 'Wheel click',
      }).setValue(this.plugin.settings.trigerkey).onChange(async (value) => {
        this.plugin.settings.trigerkey = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Enable drawing").setDesc("Toggle to enable or disable gesture drawing on the screen").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableDrawing).onChange(async (value) => {
        this.plugin.settings.enableDrawing = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Stroke color").setDesc("Select the color for the gesture stroke").addDropdown((dropdown) => {
      dropdown.addOptions({
        "accent": "Accent color",
        "red": "Red",
        "orange": "Orange",
        "yellow": "Yellow",
        "green": "Green",
        "blue": "Blue",
        "purple": "Purple",
        "custom": "Custom"
      }).setValue(this.plugin.settings.strokeColor || "accent").onChange(async (value) => {
        this.plugin.settings.strokeColor = value;
        await this.plugin.saveSettings();
        customColorSetting.setDisabled(value !== "custom");
      });
    });
    const customColorSetting = new import_obsidian.Setting(containerEl).setName("Custom stroke color").setDesc("Enter a custom color (hex or valid CSS color)").addText(
      (text) => text.setPlaceholder("#000000").setValue(this.plugin.settings.customStrokeColor || "").onChange(async (value) => {
        this.plugin.settings.customStrokeColor = value;
        await this.plugin.saveSettings();
      })
    ).setDisabled(this.plugin.settings.strokeColor !== "custom");
    new import_obsidian.Setting(containerEl).setName("Line width").setDesc("Set the thickness of the gesture stroke").addSlider(
      (slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.lineWidth).onChange(async (value) => {
        this.plugin.settings.lineWidth = value;
        await this.plugin.saveSettings();
      })
    );
  }
};


/* nosourcemap */